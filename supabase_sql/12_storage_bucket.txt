
-- Create the storage bucket for media uploads
-- The `public: true` option makes files publicly accessible via URL by default
INSERT INTO storage.buckets (id, name, public)
VALUES ('media_uploads', 'media_uploads', true)
ON CONFLICT (id) DO UPDATE SET public = true; -- Or handle conflict as needed

-- RLS Policies for 'media_uploads' bucket

-- 1. Allow public read access to all files in the bucket
DROP POLICY IF EXISTS "Allow public read access to media_uploads" ON storage.objects;
CREATE POLICY "Allow public read access to media_uploads"
ON storage.objects FOR SELECT
TO public -- Or 'anon', 'authenticated' if you want more restriction
USING (bucket_id = 'media_uploads');

-- 2. Allow authenticated users to upload files into their own folder or a general public folder
DROP POLICY IF EXISTS "Allow authenticated users to upload to media_uploads" ON storage.objects;
CREATE POLICY "Allow authenticated users to upload to media_uploads"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'media_uploads' AND
  -- Example: Ensure uploads go into a folder structure like 'public/user_id/<filename>'
  -- Or 'public/anon/<filename>' if user_id is null in media_items
  -- For simplicity, this allows upload into the root if path includes 'public/'
  -- Or, if your file_path in media_items table includes the user_id, you can use that.
  -- This example assumes media_items.user_id_uploader is the owner.
  auth.uid() IS NOT NULL -- Ensure user is authenticated
  -- You might want to restrict path creation based on owner_id if files are stored in user-specific folders
  -- For example: storage.foldername(name)[1] = auth.uid()::text
);

-- 3. Allow users to delete their own files, or admins to delete any file
DROP POLICY IF EXISTS "Allow owner or admin to delete from media_uploads" ON storage.objects;
CREATE POLICY "Allow owner or admin to delete from media_uploads"
ON storage.objects FOR DELETE
TO authenticated
USING (
  bucket_id = 'media_uploads' AND
  ( 
    auth.uid() = owner OR -- 'owner' column in storage.objects links to auth.users.id
    public.is_claims_admin() -- Assumes is_claims_admin() function exists and works
  )
);

-- 4. Allow users to update their own files (optional, if you allow overwriting/updating files)
-- Often, updates are handled as new uploads + deleting old, so this might not be strictly necessary.
-- DROP POLICY IF EXISTS "Allow owner to update their own files in media_uploads" ON storage.objects;
-- CREATE POLICY "Allow owner to update their own files in media_uploads"
-- ON storage.objects FOR UPDATE
-- TO authenticated
-- USING (
--   bucket_id = 'media_uploads' AND
--   auth.uid() = owner
-- );


-- Note: `owner` in storage.objects refers to the `auth.uid()` of the uploader.
-- The `media_items.user_id_uploader` should ideally be populated with `auth.uid()` upon insert
-- to cross-reference ownership if needed for policies on the `media_items` table itself,
-- but for storage.objects, Supabase automatically sets the `owner` column.

-- Ensure your `is_claims_admin()` function is robust and correctly identifies admins.
-- This function is typically defined in `00_setup.txt` or `03_profiles.txt`.
-- Example of what it might look like:
-- CREATE OR REPLACE FUNCTION public.is_claims_admin()
-- RETURNS boolean
-- LANGUAGE sql STABLE SECURITY DEFINER
-- AS $$
--   SELECT EXISTS (
--     SELECT 1
--     FROM public.profiles
--     WHERE id = auth.uid() AND is_admin = true
--   );
-- $$;
